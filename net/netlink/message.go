package netlink

import (
	"fmt"
	"syscall"
	"unsafe"
)

type Encoder interface {
	Encode() []byte
}

// Align rounds the length up to alignTo.
func Align(len, alignTo int) int {
	return (len + alignTo - 1) & ^(alignTo - 1)
}

type Message struct {
	Type  uint16
	Flags uint16
	Seq   uint32
	Pid   uint32
	data  []byte
}

// NewMessageFromBytes decodes the contents of the byte slice into a new
// netlink message.  The remainder of the byte slice is returned along with the
// decoded message.
func NewMessageFromBytes(b []byte) (*Message, []byte, error) {
	if len(b) < syscall.SizeofNlMsghdr {
		return nil, b, fmt.Errorf("cannot parse nlmsghdr, not enough data")
	}

	msg := &Message{}
	length := *(*uint32)(unsafe.Pointer(&b[0:4][0]))

	msg.Type = *(*uint16)(unsafe.Pointer(&b[4:6][0]))
	msg.Flags = *(*uint16)(unsafe.Pointer(&b[6:8][0]))
	msg.Seq = *(*uint32)(unsafe.Pointer(&b[8:12][0]))
	msg.Pid = *(*uint32)(unsafe.Pointer(&b[12:16][0]))

	msg.data = make([]byte, length-syscall.NLMSG_HDRLEN)
	copy(msg.data, b[syscall.NLMSG_HDRLEN:length])

	ri := Align(int(length), syscall.NLMSG_ALIGNTO)
	return msg, b[ri:], nil
}

// Append appends the generated by an encoder to the netlink message.
func (m *Message) Append(e Encoder) {
	m.data = append(m.data, e.Encode()...)
}

func (m *Message) Data() []byte {
	return m.data
}

// errorCode returns the error code associated with the netlink message.
// This function returns 0 if the message does not contain any error.
func (m *Message) errorCode() int {
	if m.Type != syscall.NLMSG_ERROR {
		return 0
	}
	ecode := *(*int32)(unsafe.Pointer(&m.data[0:4][0]))
	return -int(ecode)
}

func (m *Message) Error() error {
	ecode := m.errorCode()
	if ecode == 0 {
		return nil
	}
	return syscall.Errno(ecode)
}

func (m *Message) IsError() bool {
	return m.errorCode() != 0
}

func (m *Message) IsAck() bool {
	return m.Type == syscall.NLMSG_ERROR && m.errorCode() == 0
}

func (m *Message) encode() []byte {
	len := syscall.NLMSG_HDRLEN + len(m.data)
	b := make([]byte, len)

	*(*uint32)(unsafe.Pointer(&b[0:4][0])) = uint32(len)
	*(*uint16)(unsafe.Pointer(&b[4:6][0])) = m.Type
	*(*uint16)(unsafe.Pointer(&b[6:8][0])) = m.Flags
	*(*uint32)(unsafe.Pointer(&b[8:12][0])) = m.Seq
	*(*uint32)(unsafe.Pointer(&b[12:16][0])) = m.Pid
	copy(b[16:], m.data)

	return b
}
