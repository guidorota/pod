package netlink

import (
	"errors"
	"syscall"
	"unsafe"
)

type Encoder interface {
	Encode() []byte
}

// Align rounds the length up to alignTo.
func Align(len, alignTo int) int {
	return (len + alignTo - 1) & ^(alignTo - 1)
}

const (
	NLMSG_ALIGNTO  = syscall.NLMSG_ALIGNTO
	SizeofNlMsghdr = syscall.SizeofNlMsghdr
)

type Message struct {
	Type  uint16
	Flags uint16
	Seq   uint32
	Pid   uint32
	data  []byte
}

var ErrNoData = errors.New("cannot parse nlmsghdr, not enough data")

// DecodeMessage decodes the contents of the byte slice into a new netlink
// message.  The remainder of the byte slice is returned along with the decoded
// message.
func DecodeMessage(b []byte) (*Message, []byte, error) {
	if len(b) < SizeofNlMsghdr {
		return nil, b, ErrNoData
	}

	length := *(*uint32)(unsafe.Pointer(&b[0:4][0]))
	if uint32(len(b)) < length {
		return nil, b, ErrNoData
	}

	m := &Message{}
	m.Type = *(*uint16)(unsafe.Pointer(&b[4:6][0]))
	m.Flags = *(*uint16)(unsafe.Pointer(&b[6:8][0]))
	m.Seq = *(*uint32)(unsafe.Pointer(&b[8:12][0]))
	m.Pid = *(*uint32)(unsafe.Pointer(&b[12:16][0]))

	m.data = make([]byte, length-syscall.NLMSG_HDRLEN)
	copy(m.data, b[syscall.NLMSG_HDRLEN:length])

	r := Align(int(length), NLMSG_ALIGNTO)
	return m, b[r:], nil
}

// Append appends the generated by an encoder to the netlink message.
func (m *Message) Append(e Encoder) {
	m.data = append(m.data, e.Encode()...)
}

func (m *Message) Data() []byte {
	return m.data
}

// errorCode returns the error code associated with the netlink message.
// This function returns 0 if the message does not contain any error.
func (m *Message) errorCode() int {
	if m.Type != syscall.NLMSG_ERROR {
		return 0
	}
	ecode := *(*int32)(unsafe.Pointer(&m.data[0:4][0]))
	return -int(ecode)
}

func (m *Message) Error() error {
	ecode := m.errorCode()
	if ecode == 0 {
		return nil
	}
	return syscall.Errno(ecode)
}

func (m *Message) IsError() bool {
	return m.errorCode() != 0
}

func (m *Message) IsAck() bool {
	return m.Type == syscall.NLMSG_ERROR && m.errorCode() == 0
}

func (m *Message) encode() []byte {
	len := syscall.NLMSG_HDRLEN + len(m.data)
	b := make([]byte, len)

	*(*uint32)(unsafe.Pointer(&b[0:4][0])) = uint32(len)
	*(*uint16)(unsafe.Pointer(&b[4:6][0])) = m.Type
	*(*uint16)(unsafe.Pointer(&b[6:8][0])) = m.Flags
	*(*uint32)(unsafe.Pointer(&b[8:12][0])) = m.Seq
	*(*uint32)(unsafe.Pointer(&b[12:16][0])) = m.Pid
	copy(b[16:], m.data)

	return b
}
